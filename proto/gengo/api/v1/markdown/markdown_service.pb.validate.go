// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/v1/markdown/markdown_service.proto

package markdown

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ParseMarkdownRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParseMarkdownRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseMarkdownRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParseMarkdownRequestMultiError, or nil if none found.
func (m *ParseMarkdownRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseMarkdownRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Markdown

	if len(errors) > 0 {
		return ParseMarkdownRequestMultiError(errors)
	}

	return nil
}

// ParseMarkdownRequestMultiError is an error wrapping multiple validation
// errors returned by ParseMarkdownRequest.ValidateAll() if the designated
// constraints aren't met.
type ParseMarkdownRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseMarkdownRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseMarkdownRequestMultiError) AllErrors() []error { return m }

// ParseMarkdownRequestValidationError is the validation error returned by
// ParseMarkdownRequest.Validate if the designated constraints aren't met.
type ParseMarkdownRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseMarkdownRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseMarkdownRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseMarkdownRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseMarkdownRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseMarkdownRequestValidationError) ErrorName() string {
	return "ParseMarkdownRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ParseMarkdownRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseMarkdownRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseMarkdownRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseMarkdownRequestValidationError{}

// Validate checks the field values on ParseMarkdownResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ParseMarkdownResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParseMarkdownResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParseMarkdownResponseMultiError, or nil if none found.
func (m *ParseMarkdownResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ParseMarkdownResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParseMarkdownResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParseMarkdownResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParseMarkdownResponseValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParseMarkdownResponseMultiError(errors)
	}

	return nil
}

// ParseMarkdownResponseMultiError is an error wrapping multiple validation
// errors returned by ParseMarkdownResponse.ValidateAll() if the designated
// constraints aren't met.
type ParseMarkdownResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParseMarkdownResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParseMarkdownResponseMultiError) AllErrors() []error { return m }

// ParseMarkdownResponseValidationError is the validation error returned by
// ParseMarkdownResponse.Validate if the designated constraints aren't met.
type ParseMarkdownResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParseMarkdownResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParseMarkdownResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParseMarkdownResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParseMarkdownResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParseMarkdownResponseValidationError) ErrorName() string {
	return "ParseMarkdownResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ParseMarkdownResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParseMarkdownResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParseMarkdownResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParseMarkdownResponseValidationError{}

// Validate checks the field values on RestoreMarkdownNodesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RestoreMarkdownNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RestoreMarkdownNodesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RestoreMarkdownNodesRequestMultiError, or nil if none found.
func (m *RestoreMarkdownNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RestoreMarkdownNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RestoreMarkdownNodesRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RestoreMarkdownNodesRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RestoreMarkdownNodesRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RestoreMarkdownNodesRequestMultiError(errors)
	}

	return nil
}

// RestoreMarkdownNodesRequestMultiError is an error wrapping multiple
// validation errors returned by RestoreMarkdownNodesRequest.ValidateAll() if
// the designated constraints aren't met.
type RestoreMarkdownNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RestoreMarkdownNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RestoreMarkdownNodesRequestMultiError) AllErrors() []error { return m }

// RestoreMarkdownNodesRequestValidationError is the validation error returned
// by RestoreMarkdownNodesRequest.Validate if the designated constraints
// aren't met.
type RestoreMarkdownNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RestoreMarkdownNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RestoreMarkdownNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RestoreMarkdownNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RestoreMarkdownNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RestoreMarkdownNodesRequestValidationError) ErrorName() string {
	return "RestoreMarkdownNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RestoreMarkdownNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRestoreMarkdownNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RestoreMarkdownNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RestoreMarkdownNodesRequestValidationError{}

// Validate checks the field values on RestoreMarkdownNodesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RestoreMarkdownNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RestoreMarkdownNodesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RestoreMarkdownNodesResponseMultiError, or nil if none found.
func (m *RestoreMarkdownNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RestoreMarkdownNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Markdown

	if len(errors) > 0 {
		return RestoreMarkdownNodesResponseMultiError(errors)
	}

	return nil
}

// RestoreMarkdownNodesResponseMultiError is an error wrapping multiple
// validation errors returned by RestoreMarkdownNodesResponse.ValidateAll() if
// the designated constraints aren't met.
type RestoreMarkdownNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RestoreMarkdownNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RestoreMarkdownNodesResponseMultiError) AllErrors() []error { return m }

// RestoreMarkdownNodesResponseValidationError is the validation error returned
// by RestoreMarkdownNodesResponse.Validate if the designated constraints
// aren't met.
type RestoreMarkdownNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RestoreMarkdownNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RestoreMarkdownNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RestoreMarkdownNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RestoreMarkdownNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RestoreMarkdownNodesResponseValidationError) ErrorName() string {
	return "RestoreMarkdownNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RestoreMarkdownNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRestoreMarkdownNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RestoreMarkdownNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RestoreMarkdownNodesResponseValidationError{}

// Validate checks the field values on StringifyMarkdownNodesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StringifyMarkdownNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StringifyMarkdownNodesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StringifyMarkdownNodesRequestMultiError, or nil if none found.
func (m *StringifyMarkdownNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StringifyMarkdownNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StringifyMarkdownNodesRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StringifyMarkdownNodesRequestValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StringifyMarkdownNodesRequestValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StringifyMarkdownNodesRequestMultiError(errors)
	}

	return nil
}

// StringifyMarkdownNodesRequestMultiError is an error wrapping multiple
// validation errors returned by StringifyMarkdownNodesRequest.ValidateAll()
// if the designated constraints aren't met.
type StringifyMarkdownNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringifyMarkdownNodesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringifyMarkdownNodesRequestMultiError) AllErrors() []error { return m }

// StringifyMarkdownNodesRequestValidationError is the validation error
// returned by StringifyMarkdownNodesRequest.Validate if the designated
// constraints aren't met.
type StringifyMarkdownNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringifyMarkdownNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringifyMarkdownNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringifyMarkdownNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringifyMarkdownNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringifyMarkdownNodesRequestValidationError) ErrorName() string {
	return "StringifyMarkdownNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StringifyMarkdownNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringifyMarkdownNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringifyMarkdownNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringifyMarkdownNodesRequestValidationError{}

// Validate checks the field values on StringifyMarkdownNodesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StringifyMarkdownNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StringifyMarkdownNodesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StringifyMarkdownNodesResponseMultiError, or nil if none found.
func (m *StringifyMarkdownNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StringifyMarkdownNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlainText

	if len(errors) > 0 {
		return StringifyMarkdownNodesResponseMultiError(errors)
	}

	return nil
}

// StringifyMarkdownNodesResponseMultiError is an error wrapping multiple
// validation errors returned by StringifyMarkdownNodesResponse.ValidateAll()
// if the designated constraints aren't met.
type StringifyMarkdownNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StringifyMarkdownNodesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StringifyMarkdownNodesResponseMultiError) AllErrors() []error { return m }

// StringifyMarkdownNodesResponseValidationError is the validation error
// returned by StringifyMarkdownNodesResponse.Validate if the designated
// constraints aren't met.
type StringifyMarkdownNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StringifyMarkdownNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StringifyMarkdownNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StringifyMarkdownNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StringifyMarkdownNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StringifyMarkdownNodesResponseValidationError) ErrorName() string {
	return "StringifyMarkdownNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StringifyMarkdownNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStringifyMarkdownNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StringifyMarkdownNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StringifyMarkdownNodesResponseValidationError{}

// Validate checks the field values on GetLinkMetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLinkMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLinkMetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLinkMetadataRequestMultiError, or nil if none found.
func (m *GetLinkMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLinkMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Link

	if len(errors) > 0 {
		return GetLinkMetadataRequestMultiError(errors)
	}

	return nil
}

// GetLinkMetadataRequestMultiError is an error wrapping multiple validation
// errors returned by GetLinkMetadataRequest.ValidateAll() if the designated
// constraints aren't met.
type GetLinkMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLinkMetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLinkMetadataRequestMultiError) AllErrors() []error { return m }

// GetLinkMetadataRequestValidationError is the validation error returned by
// GetLinkMetadataRequest.Validate if the designated constraints aren't met.
type GetLinkMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLinkMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLinkMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLinkMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLinkMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLinkMetadataRequestValidationError) ErrorName() string {
	return "GetLinkMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLinkMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLinkMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLinkMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLinkMetadataRequestValidationError{}

// Validate checks the field values on LinkMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LinkMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LinkMetadataMultiError, or
// nil if none found.
func (m *LinkMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Description

	// no validation rules for Image

	if len(errors) > 0 {
		return LinkMetadataMultiError(errors)
	}

	return nil
}

// LinkMetadataMultiError is an error wrapping multiple validation errors
// returned by LinkMetadata.ValidateAll() if the designated constraints aren't met.
type LinkMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkMetadataMultiError) AllErrors() []error { return m }

// LinkMetadataValidationError is the validation error returned by
// LinkMetadata.Validate if the designated constraints aren't met.
type LinkMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkMetadataValidationError) ErrorName() string { return "LinkMetadataValidationError" }

// Error satisfies the builtin error interface
func (e LinkMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkMetadataValidationError{}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Node with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodeMultiError, or nil if none found.
func (m *Node) ValidateAll() error {
	return m.validate(true)
}

func (m *Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	switch v := m.Node.(type) {
	case *Node_LineBreakNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLineBreakNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "LineBreakNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "LineBreakNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLineBreakNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "LineBreakNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ParagraphNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParagraphNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ParagraphNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ParagraphNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParagraphNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ParagraphNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_CodeBlockNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCodeBlockNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "CodeBlockNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "CodeBlockNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCodeBlockNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "CodeBlockNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_HeadingNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHeadingNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HeadingNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HeadingNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHeadingNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "HeadingNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_HorizontalRuleNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHorizontalRuleNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HorizontalRuleNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HorizontalRuleNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHorizontalRuleNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "HorizontalRuleNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_BlockquoteNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBlockquoteNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "BlockquoteNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "BlockquoteNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBlockquoteNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "BlockquoteNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ListNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetListNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ListNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ListNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetListNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ListNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_OrderedListItemNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderedListItemNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "OrderedListItemNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "OrderedListItemNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderedListItemNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "OrderedListItemNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_UnorderedListItemNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUnorderedListItemNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "UnorderedListItemNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "UnorderedListItemNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnorderedListItemNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "UnorderedListItemNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TaskListItemNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTaskListItemNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TaskListItemNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TaskListItemNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTaskListItemNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TaskListItemNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_MathBlockNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMathBlockNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "MathBlockNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "MathBlockNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMathBlockNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "MathBlockNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TableNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTableNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TableNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TableNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTableNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TableNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_EmbeddedContentNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEmbeddedContentNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "EmbeddedContentNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "EmbeddedContentNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmbeddedContentNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "EmbeddedContentNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TextNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTextNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TextNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TextNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTextNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TextNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_BoldNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBoldNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "BoldNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "BoldNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBoldNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "BoldNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ItalicNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetItalicNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ItalicNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ItalicNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetItalicNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ItalicNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_BoldItalicNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBoldItalicNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "BoldItalicNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "BoldItalicNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBoldItalicNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "BoldItalicNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_CodeNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCodeNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "CodeNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "CodeNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCodeNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "CodeNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ImageNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetImageNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ImageNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ImageNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetImageNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ImageNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_LinkNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLinkNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "LinkNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "LinkNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLinkNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "LinkNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_AutoLinkNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAutoLinkNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "AutoLinkNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "AutoLinkNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAutoLinkNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "AutoLinkNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_TagNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTagNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TagNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "TagNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTagNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "TagNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_StrikethroughNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStrikethroughNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "StrikethroughNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "StrikethroughNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStrikethroughNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "StrikethroughNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_EscapingCharacterNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEscapingCharacterNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "EscapingCharacterNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "EscapingCharacterNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEscapingCharacterNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "EscapingCharacterNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_MathNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMathNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "MathNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "MathNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMathNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "MathNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_HighlightNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHighlightNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HighlightNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HighlightNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHighlightNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "HighlightNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_SubscriptNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscriptNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "SubscriptNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "SubscriptNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscriptNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "SubscriptNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_SuperscriptNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSuperscriptNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "SuperscriptNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "SuperscriptNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSuperscriptNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "SuperscriptNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_ReferencedContentNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReferencedContentNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ReferencedContentNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "ReferencedContentNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReferencedContentNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "ReferencedContentNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_SpoilerNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSpoilerNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "SpoilerNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "SpoilerNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSpoilerNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "SpoilerNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Node_HtmlElementNode:
		if v == nil {
			err := NodeValidationError{
				field:  "Node",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHtmlElementNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HtmlElementNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "HtmlElementNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHtmlElementNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "HtmlElementNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return NodeMultiError(errors)
	}

	return nil
}

// NodeMultiError is an error wrapping multiple validation errors returned by
// Node.ValidateAll() if the designated constraints aren't met.
type NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeMultiError) AllErrors() []error { return m }

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

// Validate checks the field values on LineBreakNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LineBreakNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LineBreakNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LineBreakNodeMultiError, or
// nil if none found.
func (m *LineBreakNode) ValidateAll() error {
	return m.validate(true)
}

func (m *LineBreakNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return LineBreakNodeMultiError(errors)
	}

	return nil
}

// LineBreakNodeMultiError is an error wrapping multiple validation errors
// returned by LineBreakNode.ValidateAll() if the designated constraints
// aren't met.
type LineBreakNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LineBreakNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LineBreakNodeMultiError) AllErrors() []error { return m }

// LineBreakNodeValidationError is the validation error returned by
// LineBreakNode.Validate if the designated constraints aren't met.
type LineBreakNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LineBreakNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LineBreakNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LineBreakNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LineBreakNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LineBreakNodeValidationError) ErrorName() string { return "LineBreakNodeValidationError" }

// Error satisfies the builtin error interface
func (e LineBreakNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLineBreakNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LineBreakNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LineBreakNodeValidationError{}

// Validate checks the field values on ParagraphNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ParagraphNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParagraphNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ParagraphNodeMultiError, or
// nil if none found.
func (m *ParagraphNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ParagraphNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ParagraphNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ParagraphNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ParagraphNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ParagraphNodeMultiError(errors)
	}

	return nil
}

// ParagraphNodeMultiError is an error wrapping multiple validation errors
// returned by ParagraphNode.ValidateAll() if the designated constraints
// aren't met.
type ParagraphNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParagraphNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParagraphNodeMultiError) AllErrors() []error { return m }

// ParagraphNodeValidationError is the validation error returned by
// ParagraphNode.Validate if the designated constraints aren't met.
type ParagraphNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParagraphNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParagraphNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParagraphNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParagraphNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParagraphNodeValidationError) ErrorName() string { return "ParagraphNodeValidationError" }

// Error satisfies the builtin error interface
func (e ParagraphNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParagraphNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParagraphNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParagraphNodeValidationError{}

// Validate checks the field values on CodeBlockNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CodeBlockNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CodeBlockNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CodeBlockNodeMultiError, or
// nil if none found.
func (m *CodeBlockNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CodeBlockNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Language

	// no validation rules for Content

	if len(errors) > 0 {
		return CodeBlockNodeMultiError(errors)
	}

	return nil
}

// CodeBlockNodeMultiError is an error wrapping multiple validation errors
// returned by CodeBlockNode.ValidateAll() if the designated constraints
// aren't met.
type CodeBlockNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CodeBlockNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CodeBlockNodeMultiError) AllErrors() []error { return m }

// CodeBlockNodeValidationError is the validation error returned by
// CodeBlockNode.Validate if the designated constraints aren't met.
type CodeBlockNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CodeBlockNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CodeBlockNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CodeBlockNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CodeBlockNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CodeBlockNodeValidationError) ErrorName() string { return "CodeBlockNodeValidationError" }

// Error satisfies the builtin error interface
func (e CodeBlockNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCodeBlockNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CodeBlockNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CodeBlockNodeValidationError{}

// Validate checks the field values on HeadingNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HeadingNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeadingNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HeadingNodeMultiError, or
// nil if none found.
func (m *HeadingNode) ValidateAll() error {
	return m.validate(true)
}

func (m *HeadingNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Level

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HeadingNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HeadingNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HeadingNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HeadingNodeMultiError(errors)
	}

	return nil
}

// HeadingNodeMultiError is an error wrapping multiple validation errors
// returned by HeadingNode.ValidateAll() if the designated constraints aren't met.
type HeadingNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeadingNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeadingNodeMultiError) AllErrors() []error { return m }

// HeadingNodeValidationError is the validation error returned by
// HeadingNode.Validate if the designated constraints aren't met.
type HeadingNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeadingNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeadingNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeadingNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeadingNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeadingNodeValidationError) ErrorName() string { return "HeadingNodeValidationError" }

// Error satisfies the builtin error interface
func (e HeadingNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeadingNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeadingNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeadingNodeValidationError{}

// Validate checks the field values on HorizontalRuleNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HorizontalRuleNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HorizontalRuleNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HorizontalRuleNodeMultiError, or nil if none found.
func (m *HorizontalRuleNode) ValidateAll() error {
	return m.validate(true)
}

func (m *HorizontalRuleNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Symbol

	if len(errors) > 0 {
		return HorizontalRuleNodeMultiError(errors)
	}

	return nil
}

// HorizontalRuleNodeMultiError is an error wrapping multiple validation errors
// returned by HorizontalRuleNode.ValidateAll() if the designated constraints
// aren't met.
type HorizontalRuleNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HorizontalRuleNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HorizontalRuleNodeMultiError) AllErrors() []error { return m }

// HorizontalRuleNodeValidationError is the validation error returned by
// HorizontalRuleNode.Validate if the designated constraints aren't met.
type HorizontalRuleNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HorizontalRuleNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HorizontalRuleNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HorizontalRuleNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HorizontalRuleNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HorizontalRuleNodeValidationError) ErrorName() string {
	return "HorizontalRuleNodeValidationError"
}

// Error satisfies the builtin error interface
func (e HorizontalRuleNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHorizontalRuleNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HorizontalRuleNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HorizontalRuleNodeValidationError{}

// Validate checks the field values on BlockquoteNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BlockquoteNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BlockquoteNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BlockquoteNodeMultiError,
// or nil if none found.
func (m *BlockquoteNode) ValidateAll() error {
	return m.validate(true)
}

func (m *BlockquoteNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockquoteNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockquoteNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockquoteNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BlockquoteNodeMultiError(errors)
	}

	return nil
}

// BlockquoteNodeMultiError is an error wrapping multiple validation errors
// returned by BlockquoteNode.ValidateAll() if the designated constraints
// aren't met.
type BlockquoteNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockquoteNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockquoteNodeMultiError) AllErrors() []error { return m }

// BlockquoteNodeValidationError is the validation error returned by
// BlockquoteNode.Validate if the designated constraints aren't met.
type BlockquoteNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockquoteNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockquoteNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockquoteNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockquoteNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockquoteNodeValidationError) ErrorName() string { return "BlockquoteNodeValidationError" }

// Error satisfies the builtin error interface
func (e BlockquoteNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlockquoteNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockquoteNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockquoteNodeValidationError{}

// Validate checks the field values on ListNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListNodeMultiError, or nil
// if none found.
func (m *ListNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ListNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for Indent

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListNodeMultiError(errors)
	}

	return nil
}

// ListNodeMultiError is an error wrapping multiple validation errors returned
// by ListNode.ValidateAll() if the designated constraints aren't met.
type ListNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListNodeMultiError) AllErrors() []error { return m }

// ListNodeValidationError is the validation error returned by
// ListNode.Validate if the designated constraints aren't met.
type ListNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListNodeValidationError) ErrorName() string { return "ListNodeValidationError" }

// Error satisfies the builtin error interface
func (e ListNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListNodeValidationError{}

// Validate checks the field values on OrderedListItemNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderedListItemNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderedListItemNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderedListItemNodeMultiError, or nil if none found.
func (m *OrderedListItemNode) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderedListItemNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	// no validation rules for Indent

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderedListItemNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderedListItemNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderedListItemNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OrderedListItemNodeMultiError(errors)
	}

	return nil
}

// OrderedListItemNodeMultiError is an error wrapping multiple validation
// errors returned by OrderedListItemNode.ValidateAll() if the designated
// constraints aren't met.
type OrderedListItemNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderedListItemNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderedListItemNodeMultiError) AllErrors() []error { return m }

// OrderedListItemNodeValidationError is the validation error returned by
// OrderedListItemNode.Validate if the designated constraints aren't met.
type OrderedListItemNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderedListItemNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderedListItemNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderedListItemNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderedListItemNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderedListItemNodeValidationError) ErrorName() string {
	return "OrderedListItemNodeValidationError"
}

// Error satisfies the builtin error interface
func (e OrderedListItemNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderedListItemNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderedListItemNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderedListItemNodeValidationError{}

// Validate checks the field values on UnorderedListItemNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnorderedListItemNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnorderedListItemNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnorderedListItemNodeMultiError, or nil if none found.
func (m *UnorderedListItemNode) ValidateAll() error {
	return m.validate(true)
}

func (m *UnorderedListItemNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Symbol

	// no validation rules for Indent

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UnorderedListItemNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UnorderedListItemNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UnorderedListItemNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UnorderedListItemNodeMultiError(errors)
	}

	return nil
}

// UnorderedListItemNodeMultiError is an error wrapping multiple validation
// errors returned by UnorderedListItemNode.ValidateAll() if the designated
// constraints aren't met.
type UnorderedListItemNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnorderedListItemNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnorderedListItemNodeMultiError) AllErrors() []error { return m }

// UnorderedListItemNodeValidationError is the validation error returned by
// UnorderedListItemNode.Validate if the designated constraints aren't met.
type UnorderedListItemNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnorderedListItemNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnorderedListItemNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnorderedListItemNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnorderedListItemNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnorderedListItemNodeValidationError) ErrorName() string {
	return "UnorderedListItemNodeValidationError"
}

// Error satisfies the builtin error interface
func (e UnorderedListItemNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnorderedListItemNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnorderedListItemNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnorderedListItemNodeValidationError{}

// Validate checks the field values on TaskListItemNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TaskListItemNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskListItemNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskListItemNodeMultiError, or nil if none found.
func (m *TaskListItemNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskListItemNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Symbol

	// no validation rules for Indent

	// no validation rules for Complete

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskListItemNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskListItemNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskListItemNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TaskListItemNodeMultiError(errors)
	}

	return nil
}

// TaskListItemNodeMultiError is an error wrapping multiple validation errors
// returned by TaskListItemNode.ValidateAll() if the designated constraints
// aren't met.
type TaskListItemNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskListItemNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskListItemNodeMultiError) AllErrors() []error { return m }

// TaskListItemNodeValidationError is the validation error returned by
// TaskListItemNode.Validate if the designated constraints aren't met.
type TaskListItemNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskListItemNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskListItemNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskListItemNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskListItemNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskListItemNodeValidationError) ErrorName() string { return "TaskListItemNodeValidationError" }

// Error satisfies the builtin error interface
func (e TaskListItemNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskListItemNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskListItemNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskListItemNodeValidationError{}

// Validate checks the field values on MathBlockNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MathBlockNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MathBlockNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MathBlockNodeMultiError, or
// nil if none found.
func (m *MathBlockNode) ValidateAll() error {
	return m.validate(true)
}

func (m *MathBlockNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return MathBlockNodeMultiError(errors)
	}

	return nil
}

// MathBlockNodeMultiError is an error wrapping multiple validation errors
// returned by MathBlockNode.ValidateAll() if the designated constraints
// aren't met.
type MathBlockNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MathBlockNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MathBlockNodeMultiError) AllErrors() []error { return m }

// MathBlockNodeValidationError is the validation error returned by
// MathBlockNode.Validate if the designated constraints aren't met.
type MathBlockNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MathBlockNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MathBlockNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MathBlockNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MathBlockNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MathBlockNodeValidationError) ErrorName() string { return "MathBlockNodeValidationError" }

// Error satisfies the builtin error interface
func (e MathBlockNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMathBlockNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MathBlockNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MathBlockNodeValidationError{}

// Validate checks the field values on TableNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TableNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TableNodeMultiError, or nil
// if none found.
func (m *TableNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TableNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetHeader() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TableNodeValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TableNodeValidationError{
						field:  fmt.Sprintf("Header[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TableNodeValidationError{
					field:  fmt.Sprintf("Header[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetRows() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TableNodeValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TableNodeValidationError{
						field:  fmt.Sprintf("Rows[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TableNodeValidationError{
					field:  fmt.Sprintf("Rows[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TableNodeMultiError(errors)
	}

	return nil
}

// TableNodeMultiError is an error wrapping multiple validation errors returned
// by TableNode.ValidateAll() if the designated constraints aren't met.
type TableNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableNodeMultiError) AllErrors() []error { return m }

// TableNodeValidationError is the validation error returned by
// TableNode.Validate if the designated constraints aren't met.
type TableNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableNodeValidationError) ErrorName() string { return "TableNodeValidationError" }

// Error satisfies the builtin error interface
func (e TableNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableNodeValidationError{}

// Validate checks the field values on EmbeddedContentNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EmbeddedContentNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EmbeddedContentNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EmbeddedContentNodeMultiError, or nil if none found.
func (m *EmbeddedContentNode) ValidateAll() error {
	return m.validate(true)
}

func (m *EmbeddedContentNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceName

	// no validation rules for Params

	if len(errors) > 0 {
		return EmbeddedContentNodeMultiError(errors)
	}

	return nil
}

// EmbeddedContentNodeMultiError is an error wrapping multiple validation
// errors returned by EmbeddedContentNode.ValidateAll() if the designated
// constraints aren't met.
type EmbeddedContentNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EmbeddedContentNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EmbeddedContentNodeMultiError) AllErrors() []error { return m }

// EmbeddedContentNodeValidationError is the validation error returned by
// EmbeddedContentNode.Validate if the designated constraints aren't met.
type EmbeddedContentNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EmbeddedContentNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EmbeddedContentNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EmbeddedContentNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EmbeddedContentNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EmbeddedContentNodeValidationError) ErrorName() string {
	return "EmbeddedContentNodeValidationError"
}

// Error satisfies the builtin error interface
func (e EmbeddedContentNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEmbeddedContentNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EmbeddedContentNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EmbeddedContentNodeValidationError{}

// Validate checks the field values on TextNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TextNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TextNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TextNodeMultiError, or nil
// if none found.
func (m *TextNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TextNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return TextNodeMultiError(errors)
	}

	return nil
}

// TextNodeMultiError is an error wrapping multiple validation errors returned
// by TextNode.ValidateAll() if the designated constraints aren't met.
type TextNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TextNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TextNodeMultiError) AllErrors() []error { return m }

// TextNodeValidationError is the validation error returned by
// TextNode.Validate if the designated constraints aren't met.
type TextNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TextNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TextNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TextNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TextNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TextNodeValidationError) ErrorName() string { return "TextNodeValidationError" }

// Error satisfies the builtin error interface
func (e TextNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTextNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TextNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TextNodeValidationError{}

// Validate checks the field values on BoldNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BoldNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BoldNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BoldNodeMultiError, or nil
// if none found.
func (m *BoldNode) ValidateAll() error {
	return m.validate(true)
}

func (m *BoldNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Symbol

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BoldNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BoldNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BoldNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BoldNodeMultiError(errors)
	}

	return nil
}

// BoldNodeMultiError is an error wrapping multiple validation errors returned
// by BoldNode.ValidateAll() if the designated constraints aren't met.
type BoldNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BoldNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BoldNodeMultiError) AllErrors() []error { return m }

// BoldNodeValidationError is the validation error returned by
// BoldNode.Validate if the designated constraints aren't met.
type BoldNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoldNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoldNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoldNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoldNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoldNodeValidationError) ErrorName() string { return "BoldNodeValidationError" }

// Error satisfies the builtin error interface
func (e BoldNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBoldNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoldNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoldNodeValidationError{}

// Validate checks the field values on ItalicNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ItalicNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ItalicNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ItalicNodeMultiError, or
// nil if none found.
func (m *ItalicNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ItalicNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Symbol

	// no validation rules for Content

	if len(errors) > 0 {
		return ItalicNodeMultiError(errors)
	}

	return nil
}

// ItalicNodeMultiError is an error wrapping multiple validation errors
// returned by ItalicNode.ValidateAll() if the designated constraints aren't met.
type ItalicNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ItalicNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ItalicNodeMultiError) AllErrors() []error { return m }

// ItalicNodeValidationError is the validation error returned by
// ItalicNode.Validate if the designated constraints aren't met.
type ItalicNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ItalicNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ItalicNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ItalicNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ItalicNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ItalicNodeValidationError) ErrorName() string { return "ItalicNodeValidationError" }

// Error satisfies the builtin error interface
func (e ItalicNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sItalicNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ItalicNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ItalicNodeValidationError{}

// Validate checks the field values on BoldItalicNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BoldItalicNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BoldItalicNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BoldItalicNodeMultiError,
// or nil if none found.
func (m *BoldItalicNode) ValidateAll() error {
	return m.validate(true)
}

func (m *BoldItalicNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Symbol

	// no validation rules for Content

	if len(errors) > 0 {
		return BoldItalicNodeMultiError(errors)
	}

	return nil
}

// BoldItalicNodeMultiError is an error wrapping multiple validation errors
// returned by BoldItalicNode.ValidateAll() if the designated constraints
// aren't met.
type BoldItalicNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BoldItalicNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BoldItalicNodeMultiError) AllErrors() []error { return m }

// BoldItalicNodeValidationError is the validation error returned by
// BoldItalicNode.Validate if the designated constraints aren't met.
type BoldItalicNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BoldItalicNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BoldItalicNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BoldItalicNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BoldItalicNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BoldItalicNodeValidationError) ErrorName() string { return "BoldItalicNodeValidationError" }

// Error satisfies the builtin error interface
func (e BoldItalicNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBoldItalicNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BoldItalicNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BoldItalicNodeValidationError{}

// Validate checks the field values on CodeNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CodeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CodeNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CodeNodeMultiError, or nil
// if none found.
func (m *CodeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CodeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return CodeNodeMultiError(errors)
	}

	return nil
}

// CodeNodeMultiError is an error wrapping multiple validation errors returned
// by CodeNode.ValidateAll() if the designated constraints aren't met.
type CodeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CodeNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CodeNodeMultiError) AllErrors() []error { return m }

// CodeNodeValidationError is the validation error returned by
// CodeNode.Validate if the designated constraints aren't met.
type CodeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CodeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CodeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CodeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CodeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CodeNodeValidationError) ErrorName() string { return "CodeNodeValidationError" }

// Error satisfies the builtin error interface
func (e CodeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCodeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CodeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CodeNodeValidationError{}

// Validate checks the field values on ImageNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImageNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImageNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImageNodeMultiError, or nil
// if none found.
func (m *ImageNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ImageNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AltText

	// no validation rules for Url

	if len(errors) > 0 {
		return ImageNodeMultiError(errors)
	}

	return nil
}

// ImageNodeMultiError is an error wrapping multiple validation errors returned
// by ImageNode.ValidateAll() if the designated constraints aren't met.
type ImageNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImageNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImageNodeMultiError) AllErrors() []error { return m }

// ImageNodeValidationError is the validation error returned by
// ImageNode.Validate if the designated constraints aren't met.
type ImageNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImageNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImageNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImageNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImageNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImageNodeValidationError) ErrorName() string { return "ImageNodeValidationError" }

// Error satisfies the builtin error interface
func (e ImageNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImageNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImageNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImageNodeValidationError{}

// Validate checks the field values on LinkNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LinkNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LinkNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LinkNodeMultiError, or nil
// if none found.
func (m *LinkNode) ValidateAll() error {
	return m.validate(true)
}

func (m *LinkNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Text

	// no validation rules for Url

	if len(errors) > 0 {
		return LinkNodeMultiError(errors)
	}

	return nil
}

// LinkNodeMultiError is an error wrapping multiple validation errors returned
// by LinkNode.ValidateAll() if the designated constraints aren't met.
type LinkNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LinkNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LinkNodeMultiError) AllErrors() []error { return m }

// LinkNodeValidationError is the validation error returned by
// LinkNode.Validate if the designated constraints aren't met.
type LinkNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LinkNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LinkNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LinkNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LinkNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LinkNodeValidationError) ErrorName() string { return "LinkNodeValidationError" }

// Error satisfies the builtin error interface
func (e LinkNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLinkNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LinkNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LinkNodeValidationError{}

// Validate checks the field values on AutoLinkNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AutoLinkNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AutoLinkNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AutoLinkNodeMultiError, or
// nil if none found.
func (m *AutoLinkNode) ValidateAll() error {
	return m.validate(true)
}

func (m *AutoLinkNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for IsRawText

	if len(errors) > 0 {
		return AutoLinkNodeMultiError(errors)
	}

	return nil
}

// AutoLinkNodeMultiError is an error wrapping multiple validation errors
// returned by AutoLinkNode.ValidateAll() if the designated constraints aren't met.
type AutoLinkNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AutoLinkNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AutoLinkNodeMultiError) AllErrors() []error { return m }

// AutoLinkNodeValidationError is the validation error returned by
// AutoLinkNode.Validate if the designated constraints aren't met.
type AutoLinkNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AutoLinkNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AutoLinkNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AutoLinkNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AutoLinkNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AutoLinkNodeValidationError) ErrorName() string { return "AutoLinkNodeValidationError" }

// Error satisfies the builtin error interface
func (e AutoLinkNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAutoLinkNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AutoLinkNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AutoLinkNodeValidationError{}

// Validate checks the field values on TagNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TagNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TagNode with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TagNodeMultiError, or nil if none found.
func (m *TagNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TagNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return TagNodeMultiError(errors)
	}

	return nil
}

// TagNodeMultiError is an error wrapping multiple validation errors returned
// by TagNode.ValidateAll() if the designated constraints aren't met.
type TagNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagNodeMultiError) AllErrors() []error { return m }

// TagNodeValidationError is the validation error returned by TagNode.Validate
// if the designated constraints aren't met.
type TagNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagNodeValidationError) ErrorName() string { return "TagNodeValidationError" }

// Error satisfies the builtin error interface
func (e TagNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTagNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagNodeValidationError{}

// Validate checks the field values on StrikethroughNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StrikethroughNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StrikethroughNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StrikethroughNodeMultiError, or nil if none found.
func (m *StrikethroughNode) ValidateAll() error {
	return m.validate(true)
}

func (m *StrikethroughNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return StrikethroughNodeMultiError(errors)
	}

	return nil
}

// StrikethroughNodeMultiError is an error wrapping multiple validation errors
// returned by StrikethroughNode.ValidateAll() if the designated constraints
// aren't met.
type StrikethroughNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StrikethroughNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StrikethroughNodeMultiError) AllErrors() []error { return m }

// StrikethroughNodeValidationError is the validation error returned by
// StrikethroughNode.Validate if the designated constraints aren't met.
type StrikethroughNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StrikethroughNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StrikethroughNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StrikethroughNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StrikethroughNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StrikethroughNodeValidationError) ErrorName() string {
	return "StrikethroughNodeValidationError"
}

// Error satisfies the builtin error interface
func (e StrikethroughNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStrikethroughNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StrikethroughNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StrikethroughNodeValidationError{}

// Validate checks the field values on EscapingCharacterNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EscapingCharacterNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EscapingCharacterNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EscapingCharacterNodeMultiError, or nil if none found.
func (m *EscapingCharacterNode) ValidateAll() error {
	return m.validate(true)
}

func (m *EscapingCharacterNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Symbol

	if len(errors) > 0 {
		return EscapingCharacterNodeMultiError(errors)
	}

	return nil
}

// EscapingCharacterNodeMultiError is an error wrapping multiple validation
// errors returned by EscapingCharacterNode.ValidateAll() if the designated
// constraints aren't met.
type EscapingCharacterNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EscapingCharacterNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EscapingCharacterNodeMultiError) AllErrors() []error { return m }

// EscapingCharacterNodeValidationError is the validation error returned by
// EscapingCharacterNode.Validate if the designated constraints aren't met.
type EscapingCharacterNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EscapingCharacterNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EscapingCharacterNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EscapingCharacterNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EscapingCharacterNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EscapingCharacterNodeValidationError) ErrorName() string {
	return "EscapingCharacterNodeValidationError"
}

// Error satisfies the builtin error interface
func (e EscapingCharacterNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEscapingCharacterNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EscapingCharacterNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EscapingCharacterNodeValidationError{}

// Validate checks the field values on MathNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MathNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MathNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MathNodeMultiError, or nil
// if none found.
func (m *MathNode) ValidateAll() error {
	return m.validate(true)
}

func (m *MathNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return MathNodeMultiError(errors)
	}

	return nil
}

// MathNodeMultiError is an error wrapping multiple validation errors returned
// by MathNode.ValidateAll() if the designated constraints aren't met.
type MathNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MathNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MathNodeMultiError) AllErrors() []error { return m }

// MathNodeValidationError is the validation error returned by
// MathNode.Validate if the designated constraints aren't met.
type MathNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MathNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MathNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MathNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MathNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MathNodeValidationError) ErrorName() string { return "MathNodeValidationError" }

// Error satisfies the builtin error interface
func (e MathNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMathNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MathNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MathNodeValidationError{}

// Validate checks the field values on HighlightNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HighlightNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HighlightNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HighlightNodeMultiError, or
// nil if none found.
func (m *HighlightNode) ValidateAll() error {
	return m.validate(true)
}

func (m *HighlightNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return HighlightNodeMultiError(errors)
	}

	return nil
}

// HighlightNodeMultiError is an error wrapping multiple validation errors
// returned by HighlightNode.ValidateAll() if the designated constraints
// aren't met.
type HighlightNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HighlightNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HighlightNodeMultiError) AllErrors() []error { return m }

// HighlightNodeValidationError is the validation error returned by
// HighlightNode.Validate if the designated constraints aren't met.
type HighlightNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HighlightNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HighlightNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HighlightNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HighlightNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HighlightNodeValidationError) ErrorName() string { return "HighlightNodeValidationError" }

// Error satisfies the builtin error interface
func (e HighlightNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHighlightNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HighlightNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HighlightNodeValidationError{}

// Validate checks the field values on SubscriptNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SubscriptNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptNodeMultiError, or
// nil if none found.
func (m *SubscriptNode) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return SubscriptNodeMultiError(errors)
	}

	return nil
}

// SubscriptNodeMultiError is an error wrapping multiple validation errors
// returned by SubscriptNode.ValidateAll() if the designated constraints
// aren't met.
type SubscriptNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptNodeMultiError) AllErrors() []error { return m }

// SubscriptNodeValidationError is the validation error returned by
// SubscriptNode.Validate if the designated constraints aren't met.
type SubscriptNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptNodeValidationError) ErrorName() string { return "SubscriptNodeValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptNodeValidationError{}

// Validate checks the field values on SuperscriptNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SuperscriptNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SuperscriptNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SuperscriptNodeMultiError, or nil if none found.
func (m *SuperscriptNode) ValidateAll() error {
	return m.validate(true)
}

func (m *SuperscriptNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return SuperscriptNodeMultiError(errors)
	}

	return nil
}

// SuperscriptNodeMultiError is an error wrapping multiple validation errors
// returned by SuperscriptNode.ValidateAll() if the designated constraints
// aren't met.
type SuperscriptNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SuperscriptNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SuperscriptNodeMultiError) AllErrors() []error { return m }

// SuperscriptNodeValidationError is the validation error returned by
// SuperscriptNode.Validate if the designated constraints aren't met.
type SuperscriptNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SuperscriptNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SuperscriptNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SuperscriptNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SuperscriptNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SuperscriptNodeValidationError) ErrorName() string { return "SuperscriptNodeValidationError" }

// Error satisfies the builtin error interface
func (e SuperscriptNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSuperscriptNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SuperscriptNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SuperscriptNodeValidationError{}

// Validate checks the field values on ReferencedContentNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReferencedContentNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReferencedContentNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReferencedContentNodeMultiError, or nil if none found.
func (m *ReferencedContentNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ReferencedContentNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceName

	// no validation rules for Params

	if len(errors) > 0 {
		return ReferencedContentNodeMultiError(errors)
	}

	return nil
}

// ReferencedContentNodeMultiError is an error wrapping multiple validation
// errors returned by ReferencedContentNode.ValidateAll() if the designated
// constraints aren't met.
type ReferencedContentNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReferencedContentNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReferencedContentNodeMultiError) AllErrors() []error { return m }

// ReferencedContentNodeValidationError is the validation error returned by
// ReferencedContentNode.Validate if the designated constraints aren't met.
type ReferencedContentNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReferencedContentNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReferencedContentNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReferencedContentNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReferencedContentNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReferencedContentNodeValidationError) ErrorName() string {
	return "ReferencedContentNodeValidationError"
}

// Error satisfies the builtin error interface
func (e ReferencedContentNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReferencedContentNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReferencedContentNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReferencedContentNodeValidationError{}

// Validate checks the field values on SpoilerNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SpoilerNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SpoilerNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SpoilerNodeMultiError, or
// nil if none found.
func (m *SpoilerNode) ValidateAll() error {
	return m.validate(true)
}

func (m *SpoilerNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	if len(errors) > 0 {
		return SpoilerNodeMultiError(errors)
	}

	return nil
}

// SpoilerNodeMultiError is an error wrapping multiple validation errors
// returned by SpoilerNode.ValidateAll() if the designated constraints aren't met.
type SpoilerNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpoilerNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpoilerNodeMultiError) AllErrors() []error { return m }

// SpoilerNodeValidationError is the validation error returned by
// SpoilerNode.Validate if the designated constraints aren't met.
type SpoilerNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpoilerNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpoilerNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpoilerNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpoilerNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpoilerNodeValidationError) ErrorName() string { return "SpoilerNodeValidationError" }

// Error satisfies the builtin error interface
func (e SpoilerNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpoilerNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpoilerNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpoilerNodeValidationError{}

// Validate checks the field values on HTMLElementNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HTMLElementNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HTMLElementNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HTMLElementNodeMultiError, or nil if none found.
func (m *HTMLElementNode) ValidateAll() error {
	return m.validate(true)
}

func (m *HTMLElementNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TagName

	// no validation rules for Attributes

	if len(errors) > 0 {
		return HTMLElementNodeMultiError(errors)
	}

	return nil
}

// HTMLElementNodeMultiError is an error wrapping multiple validation errors
// returned by HTMLElementNode.ValidateAll() if the designated constraints
// aren't met.
type HTMLElementNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HTMLElementNodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HTMLElementNodeMultiError) AllErrors() []error { return m }

// HTMLElementNodeValidationError is the validation error returned by
// HTMLElementNode.Validate if the designated constraints aren't met.
type HTMLElementNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HTMLElementNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HTMLElementNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HTMLElementNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HTMLElementNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HTMLElementNodeValidationError) ErrorName() string { return "HTMLElementNodeValidationError" }

// Error satisfies the builtin error interface
func (e HTMLElementNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHTMLElementNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HTMLElementNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HTMLElementNodeValidationError{}

// Validate checks the field values on TableNode_Row with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TableNode_Row) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TableNode_Row with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TableNode_RowMultiError, or
// nil if none found.
func (m *TableNode_Row) ValidateAll() error {
	return m.validate(true)
}

func (m *TableNode_Row) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCells() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TableNode_RowValidationError{
						field:  fmt.Sprintf("Cells[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TableNode_RowValidationError{
						field:  fmt.Sprintf("Cells[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TableNode_RowValidationError{
					field:  fmt.Sprintf("Cells[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TableNode_RowMultiError(errors)
	}

	return nil
}

// TableNode_RowMultiError is an error wrapping multiple validation errors
// returned by TableNode_Row.ValidateAll() if the designated constraints
// aren't met.
type TableNode_RowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TableNode_RowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TableNode_RowMultiError) AllErrors() []error { return m }

// TableNode_RowValidationError is the validation error returned by
// TableNode_Row.Validate if the designated constraints aren't met.
type TableNode_RowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TableNode_RowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TableNode_RowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TableNode_RowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TableNode_RowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TableNode_RowValidationError) ErrorName() string { return "TableNode_RowValidationError" }

// Error satisfies the builtin error interface
func (e TableNode_RowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTableNode_Row.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TableNode_RowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TableNode_RowValidationError{}
